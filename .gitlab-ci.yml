stages:
  - build
  - test
  - deploy

default:
  tags:
    - shell
    - clonezilla

variables:
  # Default architecture. Can be overridden in the "Run pipeline" page.
  ARCH: "amd64"
  TYPE: "stable"
  ZIP_DIR: "zip"
  CURL_OPTS: "-fsSL"

build_zip:
  stage: build
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: on_success
    - when: manual
  allow_failure: false
  script:
    - mkdir -p "${ZIP_DIR}"
    - chmod +x download-clonezilla.sh
    - |
      LATEST_ZIP=""
      # Priority 1: Direct URL from CI/CD variable
      if [ -n "${CLONEZILLA_ZIP_URL}" ]; then
        echo "INFO: Using provided CLONEZILLA_ZIP_URL: ${CLONEZILLA_ZIP_URL}"
        LATEST_ZIP=$(basename "${CLONEZILLA_ZIP_URL}")
        DEST_FILE="${ZIP_DIR}/${LATEST_ZIP}"
        echo "Downloading ${CLONEZILLA_ZIP_URL} to ${DEST_FILE}..."
        curl ${CURL_OPTS} -o "${DEST_FILE}" "${CLONEZILLA_ZIP_URL}"
        if [ $? -ne 0 ]; then
            echo "ERROR: Download from CLONEZILLA_ZIP_URL failed." >&2
            exit 1
        fi
      # Priority 2: Use the download script with ARCH and TYPE
      else
        echo "INFO: CLONEZILLA_ZIP_URL not set. Using download-clonezilla.sh with ARCH=${ARCH} and TYPE=${TYPE}."
        # The download script outputs the full path of the downloaded file
        DOWNLOADED_ZIP_PATH=$(./download-clonezilla.sh --arch "$ARCH" --type "$TYPE" -o "$ZIP_DIR")
        if [ $? -ne 0 ] || [ -z "$DOWNLOADED_ZIP_PATH" ] || [ ! -f "$DOWNLOADED_ZIP_PATH" ]; then
            echo "ERROR: Failed to auto-download Clonezilla zip using download-clonezilla.sh." >&2
            exit 1
        fi
        LATEST_ZIP=$(basename "$DOWNLOADED_ZIP_PATH")
      fi
    - |
      echo "Final ZIP file to be used: ${LATEST_ZIP}"
      # Save the exact filename to a dotenv artifact to pass to the next stage
      echo "Saving ZIP_FILE_FROM_BUILD=${LATEST_ZIP} to build.env"
      echo "ZIP_FILE_FROM_BUILD=${LATEST_ZIP}" > build.env
  artifacts:
    name: "clonezilla-live-zip-${ARCH}"
    paths:
      - "${ZIP_DIR}/"
    expire_in: 14 day
    reports:
      dotenv: build.env


.test_template:
  stage: test
  allow_failure: true
  variables:
    LIBGUESTFS_DEBUG: "0"
    LIBGUESTFS_TRACE: "0"
  dependencies:
    - build_zip
  before_script:
    - |
      echo "Setting up qemu cloud images in the project root..."
      if [ -d "/data/cloudimages" ]; then
        mkdir -p qemu/cloudimages
        ln -s /data/cloudimages/*.qcow2 qemu/cloudimages/
        echo "Linked cloud images from /data/cloudimages."
      else
        echo "Warning: /data/cloudimages not found. OS tests will fail if images are not present."
      fi
    - |
      echo "Verifying build artifact (Clonezilla ZIP)..."
      # The ZIP_FILE_FROM_BUILD variable comes from the build_zip job's dotenv report.
      if [ -z "${ZIP_FILE_FROM_BUILD}" ]; then
        echo "Error: ZIP_FILE_FROM_BUILD variable not passed from build job." >&2
        exit 1
      fi
      if ! [ -f "${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}" ]; then
        echo "Error: Artifact zip file '${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}' not found!" >&2
        echo "Listing contents of '${ZIP_DIR}/':"
        ls -l "${ZIP_DIR}/"
        exit 1
      fi
      echo "Using ZIP file from build job: ${ZIP_FILE_FROM_BUILD}"
      export ZIP_FILE="${ZIP_FILE_FROM_BUILD}"
    - |
      echo "Preparing log directory..."
      export LOG_DIR="./logs"
      mkdir -p $LOG_DIR
    - |
      echo "Setting up test data directory..."
      if [ -d "/data/dataSets" ]; then
        # Ensure dev/testData directory exists before creating symlink target
        mkdir -p dev
        rm -rf dev/testData # Remove existing placeholder if any
        ln -s /data/dataSets dev/testData
        echo "Linked /data/dataSets to dev/testData."
      else
        echo "Warning: /data/dataSets not found on runner. Data clone/restore tests might fail."
      fi
  after_script:
    - |
      mkdir -p results
      job_started_ts=$(date -d "$CI_JOB_STARTED_AT" +%s)
      job_finished_ts=$(date -d "$CI_JOB_FINISHED_AT" +%s)
      duration=$((job_finished_ts - job_started_ts))
      duration_formatted=$(date -u -d "@${duration}" +'%H:%M:%S')

      echo "job_name: $CI_JOB_NAME" > "results/${CI_JOB_NAME}.yml"
      echo "job_status: $CI_JOB_STATUS" >> "results/${CI_JOB_NAME}.yml"
      echo "job_started_at: $CI_JOB_STARTED_AT" >> "results/${CI_JOB_NAME}.yml"
      echo "job_duration: $duration_formatted" >> "results/${CI_JOB_NAME}.yml"
      echo "arch: $ARCH" >> "results/${CI_JOB_NAME}.yml"
      echo "zip: $ZIP_FILE_FROM_BUILD" >> "results/${CI_JOB_NAME}.yml"
      echo "runner_description: $CI_RUNNER_DESCRIPTION" >> "results/${CI_JOB_NAME}.yml"
      if [ -n "$FS" ]; then
        echo "fs: $FS" >> "results/${CI_JOB_NAME}.yml"
      fi

  artifacts:
    when: always
    paths:
      - logs/
      - results/
    expire_in: 5 days
  timeout: 4h

# --- OS Tests ---

test:os:ubuntu:
  extends: .test_template
  script:
    - cd jobs
    - ./test_os_ubuntu.sh --zip "../${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}" --arch "$ARCH" --no-ssh-forward

test:os:debian:
  extends: .test_template
  script:
    - cd jobs
    - ./test_os_debian.sh --zip "../${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}" --arch "$ARCH" --no-ssh-forward

#test:os:fedora:
#  extends: .test_template
#  script:
#    - |
#      os="fedora"
#      echo "--- Running OS Clone/Restore Tests for Fedora ($ARCH) ---"
#      grep -E "^\s*${os}\s+.*\s+${ARCH}\s+" qemu/cloudimages/cloud_images.conf | while IFS= read -r config_line; do
#          release=$(echo "$config_line" | awk '{print $2}')
#          image_name="${os}-${release}-${ARCH}.qcow2"
#          image_path="qemu/cloudimages/${image_name}"
#
#          if [ -f "$image_path" ]; then
#              echo "--- Testing ${image_path} ---"
#              log_file="$LOG_DIR/os_fedora_${release}_${ARCH}_$(date +%Y%m%d_%H%M%S).log"
#              ./os-clone-restore.sh --zip "${ZIP_DIR}/${ZIP_FILE}" --tmpl "$image_path" --arch "$ARCH" --validate-iso "isos/cidata.iso" --no-ssh-forward 2>&1 | tee -a "$log_file"
#              rc=${PIPESTATUS[0]}
#              if [ $rc -ne 0 ]; then
#                  echo "--- Test FAILED for ${image_path} ---"
#                  exit 1
#              fi
#              echo "--- Test PASSED for ${image_path} ---"
#          else
#              echo "Skipping test for ${os}-${release}-${ARCH}: image file not found at ${image_path}"
#          fi
#      done
#
test:os:windows11:
  extends: .test_template
  tags:
    - shell
    - clonezilla
    - windows
  script:
    - cd jobs
    - ./test_os_windows.sh --zip "../${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}" --arch "$ARCH" --no-ssh-forward

#--- Filesystem Tests ---

.fs_test_template:
  extends: .test_template
  script:
    - cd jobs
    - ./test_fs_${FS}.sh --zip "../${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}" --arch "$ARCH" --no-ssh-forward

test:fs:exfat:
  extends: .fs_test_template
  variables:
    FS: exfat

test:fs:ntfs:
  extends: .fs_test_template
  variables:
    FS: ntfs

test:fs:vfat:
  extends: .fs_test_template
  variables:
    FS: vfat

test:fs:ext4:
  extends: .fs_test_template
  variables:
    FS: ext4

test:fs:xfs:
  extends: .fs_test_template
  variables:
    FS: xfs

test:fs:btrfs:
  extends: .fs_test_template
  variables:
    FS: btrfs

test:liteserver:
  extends: .test_template
  script:
    - cd jobs
    - ./test_liteserver.sh --zip "../${ZIP_DIR}/${ZIP_FILE_FROM_BUILD}" --arch "$ARCH" --no-ssh-forward

pages:
  stage: deploy
  needs:
    - test:os:ubuntu
    - test:os:debian
    - test:os:windows11
    - test:fs:exfat
    - test:fs:ntfs
    - test:fs:vfat
    - test:fs:ext4
    - test:fs:xfs
    - test:fs:btrfs
    - test:liteserver
  script:
    - |
      set -e
      # First, we must determine the ZIP name to create the directory.
      # It's in the results artifacts from the test stage.
      FIRST_RESULT_FILE=$(find results -name "*.yml" -print -quit)
      if [ -z "$FIRST_RESULT_FILE" ]; then
        echo "ERROR: No result files found from test stage. Cannot determine ZIP name." >&2
        # Create a fallback report at the root
        mkdir -p public
        echo "<h1>Error: Test results not found. Cannot generate report.</h1>" > public/index.html
        exit 1
      fi

      ZIP_FILENAME=$(grep "zip:" "$FIRST_RESULT_FILE" | cut -d' ' -f2-)
      ZIP_BASENAME=$(basename "$ZIP_FILENAME" .zip)
      
      # --- Determine Report Directory ---
      REPORT_DIR="public/${ZIP_BASENAME}"

      echo "INFO: Generating report in directory: ${REPORT_DIR}"
      mkdir -p "${REPORT_DIR}/logs"
      if [ -d "logs" ]; then cp -r logs/* "${REPORT_DIR}/logs/"; fi

      pipeline_started_ts=$(date -d "$CI_PIPELINE_CREATED_AT" +%s)
      report_job_started_ts=$(date -d "$CI_JOB_STARTED_AT" +%s)
      pipeline_duration=$((report_job_started_ts - pipeline_started_ts))
      pipeline_duration_formatted=$(date -u -d "@${pipeline_duration}" +'%H:%M:%S')

      # Start generating index.html
      cat > "${REPORT_DIR}/index.html" <<EOF
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Test Report: '$(printf '%s' "${ZIP_BASENAME}")'</title>
          <style>
              body { font-family: sans-serif; margin: 2em; background-color: #f4f4f9; color: #333; }
              h1, h2 { color: #444; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
              table { border-collapse: collapse; width: 100%; margin-top: 20px; box-shadow: 0 2px 3px rgba(0,0,0,0.1); }
              th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
              th { background-color: #e8e8f5; }
              tr:nth-child(even) { background-color: #f9f9f9; }
              tr:hover { background-color: #f1f1f1; }
              a { color: #007bff; text-decoration: none; }
              a:hover { text-decoration: underline; }
              .summary { background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 3px rgba(0,0,0,0.1); }
              .summary p { margin: 5px 0; }
          </style>
      </head>
      <body>
          <h1>Test Report: '$(printf '%s' "${ZIP_BASENAME}")'</h1>
          
          <h2>Pipeline Summary</h2>
          <div class="summary">
              <p><strong>Pipeline ID:</strong> <a href="$(printf '%s' "${CI_PIPELINE_URL}")">$(printf '%s' "${CI_PIPELINE_ID}")</a></p>
              <p><strong>Commit:</strong> <a href="$(printf '%s' "${CI_PROJECT_URL}")/-/commit/$(printf '%s' "${CI_COMMIT_SHA}")">$(printf '%s' "${CI_COMMIT_SHORT_SHA}")</a></p>
              <p><strong>Branch:</strong> <a href="$(printf '%s' "${CI_PROJECT_URL}")/-/tree/$(printf '%s' "${CI_COMMIT_REF_NAME}")">$(printf '%s' "${CI_COMMIT_REF_NAME}")</a></p>
              <p><strong>Triggered by:</strong> $(printf '%s' "${GITLAB_USER_NAME}")</p>
              <p><strong>Pipeline Started:</strong> $(printf '%s' "${CI_PIPELINE_CREATED_AT}")</p>
              <p><strong>Total Duration:</strong> $(printf '%s' "${pipeline_duration_formatted}") (until report generation)</p>
          </div>
      EOF
      # Append Test Environment section
      ARCH_FROM_FILE=$(grep "arch:" "$FIRST_RESULT_FILE" | cut -d' ' -f2)
      cat >> "${REPORT_DIR}/index.html" <<EOF
        <h2>Test Environment</h2>
        <div class="summary">
            <p><strong>Architecture (ARCH):</strong> '$(printf '%s' "${ARCH_FROM_FILE}")'</p>
            <p><strong>Clonezilla ZIP:</strong> '$(printf '%s' "${ZIP_FILENAME}")'</p>
        </div>
      EOF
      # Append Test Results table header
      cat >> "${REPORT_DIR}/index.html" <<EOF
      <h2>Test Results</h2>
      <table>
          <thead>
              <tr>
                  <th>Test Job</th>
                  <th>Status</th>
                  <th>Duration</th>
                  <th>Runner</th>
                  <th>Filesystem</th>
                  <th>Start Time (UTC)</th>
                  <th>Log</th>
              </tr>
          </thead>
          <tbody>
      EOF
      # Loop through results and append table rows
      for file in results/*.yml; do
        if [ -f "$file" ]; then
          job_name=$(grep "job_name:" "$file" | cut -d' ' -f2)
          job_status=$(grep "job_status:" "$file" | cut -d' ' -f2)
          job_duration=$(grep "job_duration:" "$file" | cut -d' ' -f2 || echo "N/A")
          job_started=$(grep "job_started_at:" "$file" | cut -d' ' -f2- || echo "N/A")
          runner_desc=$(grep "runner_description:" "$file" | cut -d':' -f2- | xargs || echo "N/A")
          fs=$(grep "fs:" "$file" | cut -d' ' -f2 || echo "N/A")
          
          if [ "$job_status" = "success" ]; then
            status_icon="✅"
          elif [ "$job_status" = "failed" ]; then
            status_icon="❌"
          else
            status_icon="❓"
          fi
          job_started_formatted=$(date -d "$job_started" +"%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$job_started")
          
          # Links are relative to the current directory (e.g., public/clonezilla-live-amd64/)
          log_link="<a href='./logs/${job_name}.log'>Log</a>"

          cat >> "${REPORT_DIR}/index.html" <<EOF
              <tr>
                  <td>$(printf '%s' "${job_name}")</td>
                  <td>$(printf '%s' "${status_icon}") $(printf '%s' "${job_status}")</td>
                  <td>$(printf '%s' "${job_duration}")</td>
                  <td>$(printf '%s' "${runner_desc}")</td>
                  <td>$(printf '%s' "${fs}")</td>
                  <td>$(printf '%s' "${job_started_formatted}")</td>
                  <td>$(printf '%s' "${log_link}")</td>
              </tr>
      EOF
        fi
      done
      # Close the HTML file
      cat >> "${REPORT_DIR}/index.html" <<EOF
            </tbody>
        </table>
        <br>
        <p><em>For detailed logs, click on the link in the 'Log' column or <a href="./logs/">browse the raw logs directory</a>.</em></p>
      </body>
      </html>
      EOF
  artifacts:
    paths:
      - public
    expire_in: 30 days
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: always